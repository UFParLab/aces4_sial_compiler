package sial.parser.context;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import lpg.runtime.IAst;
import sial.imp.parser.Ast.IDec;
import sial.imp.parser.Ast.Ident;

import static sial.imp.parser.context.IdentUtils.*;


/**  This class stores fully qualified names visible in a sial file
 *   Since non-ambigious lookups using non-qualified names are allowed, it caches a mapping
 *   from unqualified names to qualified names.
 * 
 * @author Beverly Sanders 
 */


public class SymbolTable {

    private HashMap<String, IDec> symtab;  
    private List<String> order;  //this is to keep track of the order that names were inserted into the map.
                                 //primarily useful for keeping the order in the old sial compiler for testing purposes
    private HashMap<String, String> qualified; //maps simple names to qualified names
                                               // invariant:  (k1,k2) is in the map
                                               //   then symtab.get(k2) != null
//	private HashMap<String, IAst> cached_imported_symbols;
    private Map 
	
    boolean _symbolTablePopulated;  //initially false
    
	public SymbolTable(){
		symtab = new HashMap<String,IDec>();
		order = new ArrayList<String>();
		qualified = new HashMap<String,String>();
//		cached_imported_symbols = new HashMap<String,IAst>();
		_symbolTablePopulated = false;
	}
	
	public void set_symbolTablePopulated(boolean b) {
		_symbolTablePopulated = b;		
	}
	
	public boolean isSymbolTablePopulated(){
		return _symbolTablePopulated;
	}
	
	
	//looks up the name
	public IDec simpleLookup(String name){
		return symtab.get(name);
	}
	
	//looks up matching name in symbol table.
	//first just tries to lookup the name
	//if no match found, looks it up in the qualified cache
	//if not found, looks at all the keys and caches result.
	//if multiple possibilities found, throws an AmbiguousNameException
    public IDec lookUp(String name) throws AmbiguousNameException{
    	assert name != null;
    	IDec dec = null;
    	dec = simpleLookup(name);
    	if (dec != null || isQualified(name)) return dec;
    	//did't find name, which is unqualified.  If there is a matching qualified one
    	//return it.
    	String cachedQualifiedName = qualified.get(name);
    	if( cachedQualifiedName != null) return simpleLookup(cachedQualifiedName);
    	//check for matching qualified name in entire keyset
    	Set<String> nameSet = symtab.keySet();
        String matchingQualifiedName = null;
    	for (String key: nameSet){
    		if (IdentUtils.isQualified(key)){
    			String simple = IdentUtils.getSimpleName(key);
    			if (name.equals(simple)){
    				if (matchingQualifiedName != null){throw new AmbiguousNameException(
    						name + " is imported as " + key + " and " + matchingQualifiedName 
    						+ ". Qualify name to disambiguate.");}
    				matchingQualifiedName = key;
    				qualified.put(name,key);
    			}
    		}
    	}
    	if (matchingQualifiedName != null){
    		dec = simpleLookup(matchingQualifiedName);
    	}
    	return dec;
    }
    
    public boolean insert(String name, IDec dec) {
    	if (simpleLookup(name) != null) return false;		
    	symtab.put(name,dec);	
    	order.add(name);
    	return true;
    }
    
    //find unqualified names as keys in source, add qualfier, and insert entry in this table
    public void merge (String qualifier, SymbolTable source){
    	List<String> sourceLocalNames = source.getLocalNames();
   	    for (String name : sourceLocalNames){
   	    	IDec dec = source.simpleLookup(name);
   	    	this.insert(qualifier + '.' + name, dec);
   	    }
    }

	private List<String> getLocalNames() {
		List<String> names = order;
		List<String> locals = new ArrayList();
		for (String name: names){
			if (isSimple(name)) {locals.add(name);}
		}
		return locals;
	}
}



/*
	
//	@SuppressWarnings("unchecked")
//	public Set<String> getLocalNames(){
//		assert _symbolTablePopulated;
//		return ((HashMap<String,IAst>) symtab.clone()).keySet();
//	}
	
//	@SuppressWarnings("unchecked")
//	public Set<String> getAllNames(){
//		assert _symbolTablePopulated;
//		Set<String> names = ((HashMap<String,IAst>) symtab.clone()).keySet();
//		Set<String> importedNames = ((HashMap<String,IAst>) symtab.clone()).keySet();
//		names.addAll(importedNames);
//		return names;
//	}
	
//	public Set<String> keySet(){
//		return symtab.keySet();
//	}


///**  Looks up local Declaration of given identifier with AST node Ident
// * @param id 
// * @return IAst node representing the declaration of id, or null 
// * if not declared in this program
// */
//	public IAst getLocal(Ident id) {
//		return getLocal(id.getName());
//	}
//	
//	/**  Looks up Declaration of given identifier with AST node Ident
//	 * @param id 
//	 * @return IAst node representing the declaration of id, or null 
//	 * if neither declared in this program or cached in importedSymbols
//	 * Note that failure to return decl does not mean it is not declared
//	 * in an imported program.
//	 */	
//	public IAst get(Ident id){
//		return get(id.getName());
//	}
//
//	/**  Looks up Declaration of identifier with given name in local symbol table
//	 * @param any_case_name 
//	 * @return IAst node representing the declaration of id, or null if not declared
//	 */
//	public IAst getLocal(String any_case_name) {
//		return symtab.get(any_case_name.toLowerCase());
//	}
//
//	/**  Looks up Declaration of given identifier with name any_case_name
//	 * @param name 
//	 * @return IAst node representing the declaration of name, or null 
//	 * if neither declared in this program or cached in importedSymbols
//	 * Note that failure to return decl does not mean it is not declared
//	 * in an imported program
//	 */	
//	public IAst get(String any_case_name) {
//		String name = any_case_name.toLowerCase();
//		IAst decl = symtab.get(name);
//		return decl != null? decl : cached_imported_symbols.get(name);
//	}
//
///** Adds a &lt name, dec &rg  pair to the local symbol table
// * @param any_case_name
// * @param dec
// * @return true if the put operation succeeds, false if the name was already in the table
// */
//	public boolean putLocal(String any_case_name, IAst dec)
//	{   IAst lookedUp = get(any_case_name);
//	    if (lookedUp == null) 
//	    {  symtab.put(any_case_name.toLowerCase(), dec);
//	       return true;
//	    }
//	   return false;
//	}
//	
//	
//	/** Adds a &lt name, dec &rg  pair to the imported symbol cache
//	 * @param any_case_name
//	 * @param dec
//	 * @return true if the put operation succeeds, false if the name was 
//	 * already in either local symbol table or cache.
//	 */	
//	public boolean putImported(String any_case_name, IAst dec){
//		{   IAst lookedUp = get(any_case_name);
//	    if (lookedUp == null) 
//	    {  cached_imported_symbols.put(any_case_name.toLowerCase(), dec);
//	       return true;
//	    }
////	    if (lookedUp == dec) 
////	    	System.out.println("duplicate insert into symbol table, should this happen???");    
//	   return false;
//	}
//	}
//
//	/** Adds a &lt name, dec &rg  pair to the local symbol table 
//	 * @param id, the ast Ident node of an identifier
//	 * @param dec
//	 * @return true if the put operation succeeds, false if the name was already in the table
//	 */
//	public boolean putLocal(Ident id, IAst dec)
//	{  return putLocal(id.toString().toLowerCase(),dec);
//	}
//	
//	public boolean putImported(Ident id, IAst dec){
//		return putImported(id.toString().toLowerCase(), dec);
//	}
    
//    //TODO  not sure why this is here.  Also seems to be fixed at 4-d
//	/* Table for contraction types */
//    public HashMap<IBlockExpression, ContractionExpessionType> contractionTypes = new HashMap<IBlockExpression, ContractionExpessionType>();
//    
//    /* Methods to extract values from type*/
//    public static int get_ny(int t){return t/1000;}
//    public static int get_nx1(int t){return (t%1000)/100;}
//    public static int get_nx2(int t){return (t%100)/10;}
//    public static int get_ninc(int t){return t%10;}
//
//    /* Construct an Integer representing a contraction type */ 
//    public static Integer getContractType(int ny, int nx1, int nx2, int ninc)
//    {  return Integer.valueOf(ny*1000 + nx1*100 + nx2*10 + ninc);}
 

//    public Set<IBlockExpression> getContractionExpressions()
//    { Set<IBlockExpression> exprs = contractionTypes.keySet();
////      System.out.println("in getContractionExpressions()" + exprs);
//      return exprs;
//    }
    
//    private boolean indicesUnique(List<Ident> indices)
//    {  int size = indices.size();
//       boolean unique = true;
//       for (int i = 0; unique && i!=size-1; i++)
//       {  Ident id = indices.get(i);
//           for (int j = i+1; unique && j!= size;j++) unique = unique && !id.equals(indices.get(j));
//       }
//       return unique;      
//    }
    
    
    
//    int ninc = 0;
//    for (Object i: x1indices)
//    {  for(Object j: x2indices)
//       if (i.equals(j)) ninc++;
//    }
//    int nx1 = x1indices.size();
//    int nx2 = x2indices.size();
//    int ny = nx1 + nx2 - 2*ninc;
    
//    public static class BlockType
//    {  LinkedHashSet<String> block;
//       public BlockType(List<Ident> indices){
//       block = new LinkedHashSet<String>();
//       for( Ident id : indices) block.add(id.toString());
//       }
//       
//       public String toString()
//       {  return "block dimensions: " + block.toString();}
//    }
//    
//    public static class ContractionExpressionType
//    {  LinkedHashSet<String> y, x1, x2, common; 
//    
//       //precondition, indices for each argument are unique
//       public ContractionExpressionType(List<Ident> x1Indices, List<Ident> x2Indices){
//       x1 = new LinkedHashSet<String>();
//       for( Ident id : x1Indices) x1.add(id.toString());
//       x2 = new LinkedHashSet<String>();
//       for (Ident id : x2Indices) x2.add(id.toString());
//       /* common will hold the intersection of x1 and x2 */
//       common = new LinkedHashSet<String>(x1);
//       common.retainAll(x2);
//       /*  y holds x1 U x2 - common */
//       y = new LinkedHashSet<String>(x1);
//       y.addAll(x2);
//       y.removeAll(common);
//       }
//       
//       public String toString()
//       {  StringBuilder sb = new StringBuilder();
//          sb.append("y: " + y.toString());
//          sb.append("\nx1: " + x1.toString());
//          sb.append("\nx2: " + x2.toString());
//          sb.append("\ncommon: " + common.toString());
//          return sb.toString();
//       }
//    }



